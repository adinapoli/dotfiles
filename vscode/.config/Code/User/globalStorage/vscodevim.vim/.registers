[["%",{"text":"Untitled-1","registerMode":1}],["*",{"text":"w","registerMode":1}],["-",{"text":"w","registerMode":1}],["1",{"text":"","registerMode":2}],["2",{"text":"","registerMode":2}],["0",{"text":"## Alternative design musing (Alfredo)\n\n* The \"key points\" hit the nail on the head, it's a perfect distillation of\n  the problem space.\n\n* Making clear that a _reason_ and a _severity_ are separate entities\n  is surprisingly tricky due to partial clash in naming. I propose to\n  bikeshed the `DiagReason` constructors to be something like:\n\n  ```haskell\n  data DiagReason =\n      CompilerWarningWithoutFlag\n    | CompilerWarningWithFlag !WarningFlag\n    | CompilerErrorWithoutFlag\n  ```\n\n  It's longer to spell out, but it gives the reader a better\n  intuition, in my opinion.\n\n* Initially I was under the impression that that `DiagReason` \n  needed two extra type constructors like in\n  my !5024, but maybe we settle for a middle ground. Having\n  them was crucial to write the `flagMsg` bind in the\n  `GHC.Utils.Logger.defaultLogAction`. Check out how this is implemented\n  in !5024, with constructors renamed to match the ones in the Wiki:\n\n  ```haskell\n  flagMsg = \\case\n    WarningWithoutFlag -> Nothing\n    (WarningWithFlag wflag) -> do\n      spec <- flagSpecOf wflag\n      return (\"-W\" ++ flagSpecName spec ++ warnFlagGrp wflag)\n    ErrorWithoutFlag -> Nothing\n    (ErrorPromotedFromWarning wflag) -> do\n        spec <- flagSpecOf wflag\n        return $\n          \"-W\" ++ flagSpecName spec ++ warnFlagGrp wflag ++\n          \", -Werror=\" ++ flagSpecName spec\n    ErrorPromotedWithWError -> return \"-Werror\"\n  ```\n\n  Here, without the `ErrReasonPromotedFromWarning` constructor and\n  `ErrorPromotedWithWErorr`, we would have a plethora of failing tests due\n  to the lack of `-Werror=`. However, I think we can avoid the\n  `ErrReasonPromotedFromWarning` if we implement `flagMsg` in terms of\n  a `DiagReason` _and_ `Severity`. Sketch:\n\n  ```haskell\n  flagMsg sev = \\case\n    (WarningWithFlag wflag) | SevWarning <- sev -> do\n      spec <- flagSpecOf wflag\n      return (\"-W\" ++ flagSpecName spec ++ warnFlagGrp wflag)\n    (WarningWithFlag wflag) | SevError <- sev -> do\n      spec <- flagSpecOf wflag\n      return $\n        \"-W\" ++ flagSpecName spec ++ warnFlagGrp wflag ++\n        \", -Werror=\" ++ flagSpecName spec\n    WarningWithoutFlag -> Nothing\n    ErrorWithoutFlag   -> Nothing\n    ErrorWithWError    -> return \"-Werror\"\n  ```\n\n  However, I don't think we can avoid having the `ErrorWithWError`, \n  because the current constructors are not enough to capture all the\n  difference nuances. Therefore, this suggest `DiagReason` should be:\n\n  ```haskell\n  data DiagReason\n    = WarningWithoutFlag\n    | WarningWithFlag !WarningFlag\n    | ErrorWithoutFlag\n    | ErrorWithWError\n  ```\n\n  If you squint, you will see we need to result 4 different results out\n  of `flagMsg`, and I think this type covers them all now.\n\n* We might get lucky and not need the `defaultReasonSeverity`, but we\n  have to try it out in the code. Usually we need the `Severity` either\n  when we build a new `MsgEnvelope` or at the very last moment, when\n  we call `printOrThrowWarning` & co, up in the driver. Therefore, we\n  might have to move the `mkMsgEnvelope*` zoo of functions from\n  `GHC.Types.Errors` elsewhere (so that the module doesn't depend on the \n  `DynFlags`, which would be nasty), and pass the `DynFlags` as input to\n  the `mkMsgEnvelope*` functions. I think this is consistent with the long\n  term plan, and if the ripple effect is not too painful, we might want\n  to do this from the get go, eliminating completely the need for\n  `defaultReasonSeverity`.\n\n* I still don't see how we could properly write an\n  `instance Diagnostic TcRnMessage`. The example you give is\n  nice, but it breaks down when you _actually_ need to make a decision\n  on the fly based on the value of the `DynFlags`. Take for example\n  my `mkTcRnMessage` from WIP branch\n  (https://gitlab.haskell.org/adinapoli/ghc/-/commit/dd77bcddcd0179125295d65501c0c920fee23734):\n\n  ```haskell\n  -- | Creates a new TcRn diagnostic message.\n  mkTcRnDiagnostic :: DynFlags -> SrcSpan -> PrintUnqualified -> TcRnDiagnostic -> MsgEnvelope TcRnMessage\n  mkTcRnDiagnostic dflags loc printer msg =\n    mkMsgEnvelope loc printer (TcRnMessage $ DiagnosticMessage msg tcRnReason)\n    where\n      tcRnReason :: DiagnosticReason\n      tcRnReason = case msg of\n        TcRnUnknownMessage decMsg\n          -> diagnosticReason decMsg\n        TcRnMessageWithUnitState _ decMsg\n          -> diagnosticReason decMsg\n        TcRnBadTelescope{}\n          -> ErrReason\n        TcRnOutOfScope{}\n          -> ErrReason\n        TcRnOutOfScopeHole{}\n          -> let defer_holes           = gopt Opt_DeferTypedHoles dflags\n                 warn_holes            = wopt Opt_WarnTypedHoles dflags\n                 rea | not defer_holes = ErrReason\n                     | warn_holes      = WarnReasonWithFlag Opt_WarnTypedHoles\n                     | otherwise       = ErrReason\n             in rea\n  ```\n\n  As this proposal stand, I don't think we can write meaningfully the\n  `TcRnOutOfScopeHole` case, and this is just one of many examples.\n  \n* I think the key takeaway due to the above is that\n  the `diagReason` typeclass method has to be thought as a read-only\n  accessor method, but we shouldn't use it to actually implement the\n  logic to compute the `DiagReason`. That needs to be done elsewhere,\n  ideally in the smart constructors, and we need to have a way to\n  \"link\" these two together, so that we have no Russian Dolls, no\n  duplication but, crucially, we compute the `DiagReason` inside the\n  smart constructor, where we have the _right_ `DynFlags`, and we can\n  make decisions.","registerMode":2}],["3",{"text":"  ```haskell\n  data TcRnMessage\n  = TcRnUnknownMessage DiagnosticMessage\n  | TcRnNameShadowing ...\n  | TcRnBadTelescope ...\n  | ...\n  ```\n\n  Isn't this still exposing us to the \"Russian Doll's\" problem?\n\n  ```haskell\n  let foo = TcRnUnknownMessage (DiagnosticMessage)\n  ```","registerMode":2}],["4",{"text":"  in:","registerMode":2}],["5",{"text":"","registerMode":2}],["6",{"text":"  is a ","registerMode":2}],["7",{"text":"* We might get lucky and not need the `defaultReasonSeverity`, but we\n  have to try it out in the code. Usually we need the `Severity` either\n  when we build a new `MsgEnvelope` or at the very last moment, when\n  we call `printOrThrowWarning` & co, up in the driver. Therefore, we\n  might have to move the `mkMsgEnvelope*` zoo of functions from\n  `GHC.Types.Errors` elsewhere (so that the module doesn't depend on the \n  `DynFlags`, which would be nasty), and pass the `DynFlags` as input to\n  the `mkMsgEnvelope*` functions. I think this is consistent with the long\n  term plan, and if the ripple effect is not too painful, we might want\n  to do this from the get go, eliminating completely the need for\n  `defaultReasonSeverity`.\n","registerMode":2}],["8",{"text":"* Is it going to be bad (in terms of code clarity and performance) to\n  turn `MsgEnvelope` into a GADT and explicitly state the `Diagnostic`\n  constraint there?\n\n  ```haskell\n  ```\n","registerMode":2}],["9",{"text":"  case scenario we have to accept it for now as a necessary evil and\n  we can _eventually_ eliminate it in future iterations.\n","registerMode":2}],["/",{"text":"mkErrorTerm","registerMode":0}],["#",{"text":"atlas.cabal","registerMode":1}]]